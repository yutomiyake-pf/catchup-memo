# 「ブラウザ周りについて」

ブラウザの基本機能は**リロード、進む、戻る、アドレスバー（オムニボックス）のみ（細かく分けると他にも色々あるが）**

**URLを元にブラウザがレンダリングされる。**

ブラウザの基本機能を壊すようなアプリケーションは体験が悪い！
- スクロールが初期化される
- スクロールがガタガタする
- Enterキーでフォームが送信できない

上記は悪いユーザーエクスペリエンス！！
- アクセシビリティも悪くなる
- セキュリティの保護機能も動かなくなるかも？

## ブラウザの構造

[引用](https://taligarsiel.com/Projects/howbrowserswork1.htm)

![ブラウザの構造](https://taligarsiel.com/Projects/layers.png)

## レンダリングのエンジン

- コンテンツ（HTMLなど）を受け取って内容を描画する

- 指定されたコンテンツ（HTMLに限らず）を描画する

- Graphic Interfaceを通って描画する

### レンダリングのプロセス

**HTMLのレンダリングは **動的** にレンダリングする**

中身をJSやユーザー入力、アニメーションなどで動的に更新する。（webの特徴）

そのために**中間表現を持っている。**
HTMLをそのまま持っているわけではなくパースして変換して **木構造**として持っている（dom）（ブラウザが扱いやすい形）


`initial render→更新→更新→更新`

**木構造に対してstyleなどを持っている**

#### ①HTMLパース
**タグをネストして表現**

ブラウザでの内部表現として**木構造で表現（DOM）する。**

**JSで操作できる→DOMとJSエンジンは裏側でbindされている。これを如何に効率的に安全に行うか（Reactなど）**

#### ②Style

**①でDOMを作ったらstyleを当てていく**（被ったら詳細度で決まる）

**cssもパースしてルールセットを作成する→ルールをDOMに適用してComputed Styleを作る（まだレイアウトされていない（描画してない。色とかフォントとかが当たっているだけ、場所の情報はまだない））**

#### ③layout

**配置を計算する。**
- DOMの親から子供に再起的に計算していく。
- 子供の高さ・幅を計算したら親は子供の累積された高さ・幅と自分自身の高さ・幅にマージンを加えて高さを計算する

#### ④paint

**描画する位置とサイズが決まったら、どの順番で描画するかを決める。**

DOMの順番ではなく、後ろから前に描画する

`document.write()`は中間表現を無視するので、使ってはいけない。

### レンダリングエンジンまとめ

- HTMLは動的に更新されるモデル
- 動的に更新するために中間表現としてDOMを用意しておりJSで更新できる
- DOMに変換した後Styleを計算し、その後どこのポジションに要素を置くかというLayoutを計算する
- 最後にPaintで全面に置くか背面に置くかを決めて描画する
- document.writeは使わない

<!-- ### JSエンジン

最近のエンジンはJustInTimeコンパイラがついている。

単なるインタプリタではなく統計的に状況を見て高速化される

tokenize→木構造にする（AST）

### JITコンパイラ

### JITを殺す要因 -->

## ネットワーク

通信を行い要求されたコンテンツをダウンロードしたりアップロードしたりする。
HTTP(S)通信を行うレイヤー。近年はHTTP/3などが有効になりつつある。

通信を行うとは

- IP/Portをクライアントが知っていて
- サーバーが待っていて
- そこに接続し
- 接続を確立したらデータの交換を行う

**3回の接続確認をおこなう（3 way handshake）（HTTPなら）**

**HTTPSの場合暗号化のためのやりとりがさらに行われる。**

**TCPのやりとりの後に暗号化のためのやりとりが行われる。**

### データのやりとり

接続が確立した後にHTTPプロトコルによるデータのやりとり
リクエストを送りレスポンスが返ってくる

200系：成功

300系：リダイレクトメッセージ

400系：クライアントエラー

500系：サーバーエラー

HTTP2で接続コストの低減ができたが問題もある→**TCPのレイヤーで不整合があると不整合が訂正されるまで全体がブロックされる**

それを改善したのがHTTP/3→**HTTP3では接続内出のデータの不整合が発生しても全体をストップさせずに該当のストリームのみ訂正される**

## データストレージ

**レスポンスの情報（cache）やユーザーの情報（cookie, local storage）に蓄積しておく仕組み**

### Cache storage

サーバー側がHTTPレスポンスヘッダーにキャッシュとして保存して良いかどうか。**キャッシュ有効期間を示せばキャッシュが有効になる。**

**Cache-Control/ETagといったキャッシュ用のヘッダーを活用する。**

### Cookie storage

クライアント内のデータとして保存されブラウザからサーバに毎回リクエストが送られる。

- セッション管理（ログイン、ショッピングカート）
- パーソナライズ（ユーザー設定、テーマなど）
- トラッキング（ユーザーの行動記録分析）

**レスポンスヘッダーにSet-Cookieから始まるデータを入力されることで保存させることができ、次回以降のリクエストでそのCookieがサーバーに送られる**
